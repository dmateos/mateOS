#include "ugfx.h"
#include "syscalls.h"

int ugfx_width = 320;
int ugfx_height = 200;
static int ugfx_bpp = 8;
static unsigned char *framebuffer = (unsigned char *)0;
static unsigned short palette565[256];
static int palette565_init = 0;

// 8x8 bitmap font (ASCII 32-126) - same as kernel's font8x8
static const unsigned char font8x8[95][8] = {
    // 32: space
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 33: !
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},
    // 34: "
    {0x36, 0x36, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 35: #
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},
    // 36: $
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},
    // 37: %
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},
    // 38: &
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},
    // 39: '
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 40: (
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},
    // 41: )
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},
    // 42: *
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},
    // 43: +
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},
    // 44: ,
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},
    // 45: -
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},
    // 46: .
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},
    // 47: /
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},
    // 48: 0
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},
    // 49: 1
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},
    // 50: 2
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},
    // 51: 3
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},
    // 52: 4
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},
    // 53: 5
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},
    // 54: 6
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},
    // 55: 7
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},
    // 56: 8
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},
    // 57: 9
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},
    // 58: :
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},
    // 59: ;
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},
    // 60: <
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},
    // 61: =
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},
    // 62: >
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},
    // 63: ?
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},
    // 64: @
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},
    // 65: A
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},
    // 66: B
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},
    // 67: C
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},
    // 68: D
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},
    // 69: E
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},
    // 70: F
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},
    // 71: G
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},
    // 72: H
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},
    // 73: I
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    // 74: J
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},
    // 75: K
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},
    // 76: L
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},
    // 77: M
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},
    // 78: N
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},
    // 79: O
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},
    // 80: P
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},
    // 81: Q
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},
    // 82: R
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},
    // 83: S
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},
    // 84: T
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    // 85: U
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},
    // 86: V
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},
    // 87: W
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},
    // 88: X
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},
    // 89: Y
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},
    // 90: Z
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},
    // 91: [
    {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},
    // 92: backslash
    {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},
    // 93: ]
    {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},
    // 94: ^
    {0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},
    // 95: _
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
    // 96: `
    {0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},
    // 97: a
    {0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},
    // 98: b
    {0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},
    // 99: c
    {0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},
    // 100: d
    {0x38, 0x30, 0x30, 0x3E, 0x33, 0x33, 0x6E, 0x00},
    // 101: e
    {0x00, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00},
    // 102: f
    {0x1C, 0x36, 0x06, 0x0F, 0x06, 0x06, 0x0F, 0x00},
    // 103: g
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},
    // 104: h
    {0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},
    // 105: i
    {0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    // 106: j
    {0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},
    // 107: k
    {0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},
    // 108: l
    {0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},
    // 109: m
    {0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},
    // 110: n
    {0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},
    // 111: o
    {0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},
    // 112: p
    {0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},
    // 113: q
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},
    // 114: r
    {0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},
    // 115: s
    {0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},
    // 116: t
    {0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},
    // 117: u
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},
    // 118: v
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},
    // 119: w
    {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},
    // 120: x
    {0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},
    // 121: y
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},
    // 122: z
    {0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},
    // 123: {
    {0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},
    // 124: |
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},
    // 125: }
    {0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},
    // 126: ~
    {0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

static unsigned short rgb888_to_565(unsigned int r, unsigned int g,
                                    unsigned int b) {
    return (unsigned short)(((r & 0xF8u) << 8) | ((g & 0xFCu) << 3) | (b >> 3));
}

static void ugfx_init_palette565(void) {
    if (palette565_init)
        return;

    static const unsigned char cga_palette[16][3] = {
        {0, 0, 0},    {0, 0, 42},   {0, 42, 0},   {0, 42, 42},
        {42, 0, 0},   {42, 0, 42},  {42, 21, 0},  {42, 42, 42},
        {21, 21, 21}, {21, 21, 63}, {21, 63, 21}, {21, 63, 63},
        {63, 21, 21}, {63, 21, 63}, {63, 63, 21}, {63, 63, 63},
    };

    for (int i = 0; i < 16; i++) {
        unsigned int r = (unsigned int)cga_palette[i][0] * 255u / 63u;
        unsigned int g = (unsigned int)cga_palette[i][1] * 255u / 63u;
        unsigned int b = (unsigned int)cga_palette[i][2] * 255u / 63u;
        palette565[i] = rgb888_to_565(r, g, b);
    }

    unsigned char idx = 16;
    for (int r = 0; r < 6; r++) {
        for (int g = 0; g < 6; g++) {
            for (int b = 0; b < 6; b++) {
                unsigned int rr = (unsigned int)(r * 255 / 5);
                unsigned int gg = (unsigned int)(g * 255 / 5);
                unsigned int bb = (unsigned int)(b * 255 / 5);
                palette565[idx++] = rgb888_to_565(rr, gg, bb);
            }
        }
    }

    for (int i = 0; i < 24; i++) {
        unsigned int v = (unsigned int)(i * 255 / 23);
        palette565[232 + i] = rgb888_to_565(v, v, v);
    }

    palette565_init = 1;
}

static inline void fb_write_idx(int x, int y, unsigned char color) {
    if (ugfx_bpp == 16) {
        ((unsigned short *)framebuffer)[y * ugfx_width + x] = palette565[color];
    } else {
        framebuffer[y * ugfx_width + x] = color;
    }
}

static inline unsigned char fb_read_idx(int x, int y) {
    if (ugfx_bpp == 16)
        return 0;
    return framebuffer[y * ugfx_width + x];
}

int ugfx_init(void) {
    framebuffer = gfx_init();
    if (!framebuffer)
        return -1;

    unsigned int info = gfx_info();
    {
        int bpp = (int)((info >> 24) & 0xFF);
        int w12 = (int)((info >> 12) & 0xFFF);
        int h12 = (int)(info & 0xFFF);

        if (bpp >= 8 && w12 > 0 && h12 > 0) {
            ugfx_bpp = bpp;
            ugfx_width = w12;
            ugfx_height = h12;
        } else {
            // Backward-compatible parse for older kernels.
            ugfx_bpp = 8;
            ugfx_width = (int)(info >> 16);
            ugfx_height = (int)(info & 0xFFFF);
        }
    }
    if (ugfx_bpp == 16)
        ugfx_init_palette565();

    return 0;
}

void ugfx_exit(void) {
    gfx_exit();
    framebuffer = (unsigned char *)0;
}

void ugfx_pixel(int x, int y, unsigned char color) {
    if (x < 0 || x >= ugfx_width || y < 0 || y >= ugfx_height)
        return;
    fb_write_idx(x, y, color);
}

unsigned char ugfx_read_pixel(int x, int y) {
    if (x < 0 || x >= ugfx_width || y < 0 || y >= ugfx_height)
        return 0;
    return fb_read_idx(x, y);
}

void ugfx_rect(int x, int y, int w, int h, unsigned char color) {
    for (int row = y; row < y + h; row++) {
        if (row < 0 || row >= ugfx_height)
            continue;
        for (int col = x; col < x + w; col++) {
            if (col < 0 || col >= ugfx_width)
                continue;
            fb_write_idx(col, row, color);
        }
    }
}

void ugfx_rect_outline(int x, int y, int w, int h, unsigned char color) {
    ugfx_hline(x, y, w, color);
    ugfx_hline(x, y + h - 1, w, color);
    ugfx_vline(x, y, h, color);
    ugfx_vline(x + w - 1, y, h, color);
}

void ugfx_clear(unsigned char color) {
    if (ugfx_bpp == 16) {
        unsigned short c = palette565[color];
        unsigned short *fb16 = (unsigned short *)framebuffer;
        for (int i = 0; i < ugfx_width * ugfx_height; i++) {
            fb16[i] = c;
        }
    } else {
        for (int i = 0; i < ugfx_width * ugfx_height; i++) {
            framebuffer[i] = color;
        }
    }
}

void ugfx_hline(int x, int y, int w, unsigned char color) {
    if (y < 0 || y >= ugfx_height)
        return;
    for (int i = 0; i < w; i++) {
        int cx = x + i;
        if (cx >= 0 && cx < ugfx_width) {
            fb_write_idx(cx, y, color);
        }
    }
}

void ugfx_vline(int x, int y, int h, unsigned char color) {
    if (x < 0 || x >= ugfx_width)
        return;
    for (int i = 0; i < h; i++) {
        int cy = y + i;
        if (cy >= 0 && cy < ugfx_height) {
            fb_write_idx(x, cy, color);
        }
    }
}

void ugfx_char(int x, int y, char c, unsigned char fg) {
    if (c < 32 || c > 126)
        return;
    const unsigned char *glyph = font8x8[c - 32];
    for (int row = 0; row < 8; row++) {
        unsigned char bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            if (bits & (1 << col)) {
                ugfx_pixel(x + col, y + row, fg);
            }
        }
    }
}

void ugfx_string(int x, int y, const char *str, unsigned char fg) {
    int cx = x;
    while (*str) {
        if (*str == '\n') {
            y += 10;
            cx = x;
        } else {
            ugfx_char(cx, y, *str, fg);
            cx += 8;
        }
        str++;
    }
}

void ugfx_string_bg(int x, int y, const char *str, unsigned char fg,
                    unsigned char bg) {
    int cx = x;
    while (*str) {
        if (*str == '\n') {
            y += 10;
            cx = x;
        } else {
            ugfx_rect(cx, y, 8, 8, bg);
            ugfx_char(cx, y, *str, fg);
            cx += 8;
        }
        str++;
    }
}

// Buffer-mode drawing functions (for windowed child apps)

void ugfx_buf_pixel(unsigned char *buf, int bw, int bh, int x, int y,
                    unsigned char color) {
    if (x < 0 || x >= bw || y < 0 || y >= bh)
        return;
    buf[y * bw + x] = color;
}

void ugfx_buf_rect(unsigned char *buf, int bw, int bh, int x, int y, int w,
                   int h, unsigned char color) {
    for (int row = y; row < y + h; row++) {
        if (row < 0 || row >= bh)
            continue;
        for (int col = x; col < x + w; col++) {
            if (col < 0 || col >= bw)
                continue;
            buf[row * bw + col] = color;
        }
    }
}

void ugfx_buf_clear(unsigned char *buf, int bw, int bh, unsigned char color) {
    for (int i = 0; i < bw * bh; i++)
        buf[i] = color;
}

void ugfx_buf_char(unsigned char *buf, int bw, int bh, int x, int y, char c,
                   unsigned char fg) {
    if (c < 32 || c > 126)
        return;
    const unsigned char *glyph = font8x8[c - 32];
    for (int row = 0; row < 8; row++) {
        unsigned char bits = glyph[row];
        for (int col = 0; col < 8; col++) {
            if (bits & (1 << col)) {
                ugfx_buf_pixel(buf, bw, bh, x + col, y + row, fg);
            }
        }
    }
}

void ugfx_buf_string(unsigned char *buf, int bw, int bh, int x, int y,
                     const char *str, unsigned char fg) {
    int cx = x;
    while (*str) {
        if (*str == '\n') {
            y += 10;
            cx = x;
        } else {
            ugfx_buf_char(buf, bw, bh, cx, y, *str, fg);
            cx += 8;
        }
        str++;
    }
}

void ugfx_buf_hline(unsigned char *buf, int bw, int bh, int x, int y, int w,
                    unsigned char color) {
    if (y < 0 || y >= bh)
        return;
    for (int i = 0; i < w; i++) {
        int cx = x + i;
        if (cx >= 0 && cx < bw)
            buf[y * bw + cx] = color;
    }
}

void ugfx_present(const unsigned char *buf, int bw, int bh) {
    if (!framebuffer || !buf)
        return;

    int w = (bw < ugfx_width) ? bw : ugfx_width;
    int h = (bh < ugfx_height) ? bh : ugfx_height;
    if (w <= 0 || h <= 0)
        return;

    if (ugfx_bpp == 16) {
        unsigned short *fb16 = (unsigned short *)framebuffer;
        for (int y = 0; y < h; y++) {
            int src_off = y * bw;
            int dst_off = y * ugfx_width;
            for (int x = 0; x < w; x++) {
                fb16[dst_off + x] = palette565[buf[src_off + x]];
            }
        }
    } else {
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                framebuffer[y * ugfx_width + x] = buf[y * bw + x];
            }
        }
    }
}

unsigned char ugfx_getkey(void) { return getkey(0); }

unsigned char ugfx_waitkey(void) {
    unsigned char key;
    while (!(key = getkey(0))) {
        yield();
    }
    return key;
}
